//@ requireOptions("--useWasmSIMD=1")
//@ skip if !$isSIMDPlatform
import { runSIMDTests } from "./simd-instructions-lib.js"
import * as assert from "../assert.js"

const verbose = false;

// Table-driven test data for SIMD integer arithmetic instructions
// Each entry: [instruction, input0, input1, expected_output]
const arithmeticTests = [
    // i8x16.add tests
    [
        "i8x16.add",
        "(v128.const i8x16 0x01 0x02 0x7F 0x80 0xFF 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xA0)",
        "(v128.const i8x16 0x01 0x02 0x01 0x01 0x01 0xFF 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xA0)",
        [0x02, 0x04, 0x80, 0x81, 0x00, 0xFF, 0x20, 0x40, 0x60, 0x80, 0xA0, 0xC0, 0xE0, 0x00, 0x20, 0x40]
    ],
    [
        "i8x16.add",
        "(v128.const i8x16 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00)",
        "(v128.const i8x16 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF)",
        [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    ],

    // i8x16.sub tests
    [
        "i8x16.sub",
        "(v128.const i8x16 0x02 0x04 0x80 0x81 0x00 0xFF 0x20 0x40 0x60 0x80 0xA0 0xC0 0xE0 0x00 0x20 0x40)",
        "(v128.const i8x16 0x01 0x02 0x01 0x01 0x01 0xFF 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xA0)",
        [0x01, 0x02, 0x7F, 0x80, 0xFF, 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xA0]
    ],
    [
        "i8x16.sub",
        "(v128.const i8x16 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF)",
        "(v128.const i8x16 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01)",
        [0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE]
    ],

    // i8x16.add_sat_s tests (signed saturated add)
    [
        "i8x16.add_sat_s",
        "(v128.const i8x16 0x7F 0x7E 0x80 0x81 0x00 0xFF 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x7F 0x80 0x81)",
        "(v128.const i8x16 0x01 0x02 0x01 0x01 0x01 0x01 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x01 0x01 0x01)",
        [0x7F, 0x7F, 0x81, 0x82, 0x01, 0x00, 0x20, 0x40, 0x60, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x81, 0x82]
    ],

    // i8x16.add_sat_u tests (unsigned saturated add)
    [
        "i8x16.add_sat_u",
        "(v128.const i8x16 0xFF 0xFE 0x80 0x81 0x00 0x01 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0xFF 0xFE 0xFD)",
        "(v128.const i8x16 0x01 0x02 0x01 0x01 0x01 0x01 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x01 0x02 0x03)",
        [0xFF, 0xFF, 0x81, 0x82, 0x01, 0x02, 0x20, 0x40, 0x60, 0x80, 0xA0, 0xC0, 0xE0, 0xFF, 0xFF, 0xFF]
    ],

    // i8x16.sub_sat_s tests (signed saturated subtract)
    [
        "i8x16.sub_sat_s",
        "(v128.const i8x16 0x80 0x81 0x7F 0x7E 0x00 0xFF 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x81 0x82)",
        "(v128.const i8x16 0x01 0x01 0x01 0x02 0x01 0x01 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x01 0x01 0x01)",
        [0x80, 0x80, 0x7E, 0x7C, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x81]
    ],

    // i8x16.sub_sat_u tests (unsigned saturated subtract)
    [
        "i8x16.sub_sat_u",
        "(v128.const i8x16 0x00 0x01 0x80 0x81 0xFF 0xFE 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x00 0x01 0x02)",
        "(v128.const i8x16 0x01 0x01 0x01 0x01 0x01 0x02 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x01 0x01 0x01)",
        [0x00, 0x00, 0x7F, 0x80, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]
    ],

    // i16x8.add tests
    [
        "i16x8.add",
        "(v128.const i16x8 0x0001 0x0002 0x7FFF 0x8000 0xFFFF 0x0000 0x1000 0x2000)",
        "(v128.const i16x8 0x0001 0x0002 0x0001 0x0001 0x0001 0xFFFF 0x1000 0x2000)",
        [0x0002, 0x0004, 0x8000, 0x8001, 0x0000, 0xFFFF, 0x2000, 0x4000]
    ],

    // i16x8.sub tests
    [
        "i16x8.sub",
        "(v128.const i16x8 0x0002 0x0004 0x8000 0x8001 0x0000 0xFFFF 0x2000 0x4000)",
        "(v128.const i16x8 0x0001 0x0002 0x0001 0x0001 0x0001 0xFFFF 0x1000 0x2000)",
        [0x0001, 0x0002, 0x7FFF, 0x8000, 0xFFFF, 0x0000, 0x1000, 0x2000]
    ],

    // i16x8.mul tests
    [
        "i16x8.mul",
        "(v128.const i16x8 0x0002 0x0003 0x0004 0x0005 0x0006 0x0007 0x0008 0x0009)",
        "(v128.const i16x8 0x0002 0x0003 0x0004 0x0005 0x0006 0x0007 0x0008 0x0009)",
        [0x0004, 0x0009, 0x0010, 0x0019, 0x0024, 0x0031, 0x0040, 0x0051]
    ],

    // i16x8.add_sat_s tests (signed saturated add)
    [
        "i16x8.add_sat_s",
        "(v128.const i16x8 0x7FFF 0x7FFE 0x8000 0x8001 0x0000 0xFFFF 0x1000 0x7FFF)",
        "(v128.const i16x8 0x0001 0x0002 0x0001 0x0001 0x0001 0x0001 0x1000 0x0001)",
        [0x7FFF, 0x7FFF, 0x8001, 0x8002, 0x0001, 0x0000, 0x2000, 0x7FFF]
    ],

    // i16x8.add_sat_u tests (unsigned saturated add)
    [
        "i16x8.add_sat_u",
        "(v128.const i16x8 0xFFFF 0xFFFE 0x8000 0x8001 0x0000 0x0001 0x1000 0xFFFF)",
        "(v128.const i16x8 0x0001 0x0002 0x0001 0x0001 0x0001 0x0001 0x1000 0x0001)",
        [0xFFFF, 0xFFFF, 0x8001, 0x8002, 0x0001, 0x0002, 0x2000, 0xFFFF]
    ],

    // i16x8.sub_sat_s tests (signed saturated subtract)
    [
        "i16x8.sub_sat_s",
        "(v128.const i16x8 0x8000 0x8001 0x7FFF 0x7FFE 0x0000 0xFFFF 0x1000 0x8000)",
        "(v128.const i16x8 0x0001 0x0001 0x0001 0x0002 0x0001 0x0001 0x1000 0x0001)",
        [0x8000, 0x8000, 0x7FFE, 0x7FFC, 0xFFFF, 0xFFFE, 0x0000, 0x8000]
    ],

    // i16x8.sub_sat_u tests (unsigned saturated subtract)
    [
        "i16x8.sub_sat_u",
        "(v128.const i16x8 0x0000 0x0001 0x8000 0x8001 0xFFFF 0xFFFE 0x1000 0x0000)",
        "(v128.const i16x8 0x0001 0x0001 0x0001 0x0001 0x0001 0x0002 0x1000 0x0001)",
        [0x0000, 0x0000, 0x7FFF, 0x8000, 0xFFFE, 0xFFFC, 0x0000, 0x0000]
    ],

    // i32x4.add tests
    [
        "i32x4.add",
        "(v128.const i32x4 0x00000001 0x00000002 0x7FFFFFFF 0x80000000)",
        "(v128.const i32x4 0x00000001 0x00000002 0x00000001 0x00000001)",
        [0x00000002, 0x00000004, 0x80000000, 0x80000001]
    ],

    // i32x4.sub tests
    [
        "i32x4.sub",
        "(v128.const i32x4 0x00000002 0x00000004 0x80000000 0x80000001)",
        "(v128.const i32x4 0x00000001 0x00000002 0x00000001 0x00000001)",
        [0x00000001, 0x00000002, 0x7FFFFFFF, 0x80000000]
    ],

    // i32x4.mul tests
    [
        "i32x4.mul",
        "(v128.const i32x4 0x00000002 0x00000003 0x00000004 0x00000005)",
        "(v128.const i32x4 0x00000002 0x00000003 0x00000004 0x00000005)",
        [0x00000004, 0x00000009, 0x00000010, 0x00000019]
    ],

    // i64x2.add tests
    [
        "i64x2.add",
        "(v128.const i64x2 0x0000000000000001 0x7FFFFFFFFFFFFFFF)",
        "(v128.const i64x2 0x0000000000000001 0x0000000000000001)",
        [0x0000000000000002n, 0x8000000000000000n]
    ],

    // i64x2.sub tests
    [
        "i64x2.sub",
        "(v128.const i64x2 0x0000000000000002 0x8000000000000000)",
        "(v128.const i64x2 0x0000000000000001 0x0000000000000001)",
        [0x0000000000000001n, 0x7FFFFFFFFFFFFFFFn]
    ],

    // i64x2.mul tests - comprehensive testing including wrapping
    [
        "i64x2.mul",
        "(v128.const i64x2 0x0000000000000002 0x0000000000000003)",
        "(v128.const i64x2 0x0000000000000002 0x0000000000000003)",
        [0x0000000000000004n, 0x0000000000000009n]
    ],
    // Test wrapping behavior with large numbers
    [
        "i64x2.mul",
        "(v128.const i64x2 0xFFFFFFFFFFFFFFFF 0x8000000000000000)",
        "(v128.const i64x2 0x0000000000000002 0x0000000000000002)",
        [0xFFFFFFFFFFFFFFFEn, 0x0000000000000000n]  // -1 * 2 = -2 (0xFFFE...), MIN_INT64 * 2 = 0 (wraps)
    ],
    // Test multiplication that causes overflow/wrapping
    [
        "i64x2.mul",
        "(v128.const i64x2 0x0000000100000000 0x0000000200000000)",
        "(v128.const i64x2 0x0000000100000000 0x0000000200000000)",
        [0x0000000000000000n, 0x0000000000000000n]  // Both overflow and wrap to 0
    ],
    // Test with maximum positive values
    [
        "i64x2.mul",
        "(v128.const i64x2 0x7FFFFFFFFFFFFFFF 0x0000000000000001)",
        "(v128.const i64x2 0x0000000000000002 0x7FFFFFFFFFFFFFFF)",
        [0xFFFFFFFFFFFFFFFEn, 0x7FFFFFFFFFFFFFFFn]  // MAX_INT64 * 2 wraps to -2, 1 * MAX_INT64 = MAX_INT64
    ],
    // Test edge case: multiply by zero
    [
        "i64x2.mul",
        "(v128.const i64x2 0xFFFFFFFFFFFFFFFF 0x8000000000000000)",
        "(v128.const i64x2 0x0000000000000000 0x0000000000000000)",
        [0x0000000000000000n, 0x0000000000000000n]
    ],
    // Test edge case: multiply by one
    [
        "i64x2.mul",
        "(v128.const i64x2 0xFFFFFFFFFFFFFFFF 0x8000000000000000)",
        "(v128.const i64x2 0x0000000000000001 0x0000000000000001)",
        [0xFFFFFFFFFFFFFFFFn, 0x8000000000000000n]
    ],
    // Test large prime numbers that will cause wrapping
    [
        "i64x2.mul",
        "(v128.const i64x2 0x00000000FFFFFFFF 0x0000FFFFFFFFFFFF)",
        "(v128.const i64x2 0x00000000FFFFFFFF 0x0000000000000010)",
        [0xFFFFFFFE00000001n, 0x000FFFFFFFFFFFF0n]  // Test 32-bit and 48-bit boundary cases
    ]
];

await runSIMDTests(arithmeticTests, verbose, "SIMD arithmetic");
